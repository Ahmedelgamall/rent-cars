<?php // generated by https://www.devsense.com/

/**
 * Programs store and operate on numbers using a locale-independent binary representation. When displaying or printing a number it is converted to a locale-specific string. For example, the number 12345.67 is "12,345.67" in the US, "12 345,67" in France and "12.345,67" in Germany.
 * By invoking the methods provided by the NumberFormatter class, you can format numbers, currencies, and percentages according to the specified or default locale. NumberFormatter is locale-sensitive so you need to create a new NumberFormatter for each locale. NumberFormatter methods format primitive-type numbers, such as double and output the number as a locale-specific string.
 * For currencies you can use currency format type to create a formatter that returns a string with the formatted number and the appropriate currency sign. Of course, the NumberFormatter class is unaware of exchange rates so, the number output is the same regardless of the specified currency. This means that the same number has different monetary values depending on the currency locale. If the number is 9988776.65 the results will be:
 * In order to format percentages, create a locale-specific formatter with percentage format type. With this formatter, a decimal fraction such as 0.75 is displayed as 75%.
 * For more complex formatting, like spelled-out numbers, the rule-based number formatters are used.
 */
class NumberFormatter
{
	#region Constants

	/**
	 * @var int
	 */
	const CURRENCY = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const CURRENCY_ACCOUNTING = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const CURRENCY_CODE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const CURRENCY_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DECIMAL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DECIMAL_ALWAYS_SHOWN = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DECIMAL_SEPARATOR_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DEFAULT_RULESET = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DEFAULT_STYLE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DIGIT_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const DURATION = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const EXPONENTIAL_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const FORMAT_WIDTH = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const FRACTION_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const GROUPING_SEPARATOR_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const GROUPING_SIZE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const GROUPING_USED = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const IGNORE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const INFINITY_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const INTEGER_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const INTL_CURRENCY_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const LENIENT_PARSE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MAX_FRACTION_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MAX_INTEGER_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MAX_SIGNIFICANT_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MINUS_SIGN_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MIN_FRACTION_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MIN_INTEGER_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MIN_SIGNIFICANT_DIGITS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MONETARY_GROUPING_SEPARATOR_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MONETARY_SEPARATOR_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const MULTIPLIER = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const NAN_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const NEGATIVE_PREFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const NEGATIVE_SUFFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ORDINAL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PADDING_CHARACTER = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PADDING_POSITION = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PAD_AFTER_PREFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PAD_AFTER_SUFFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PAD_BEFORE_PREFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PAD_BEFORE_SUFFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PAD_ESCAPE_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PARSE_INT_ONLY = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PATTERN_DECIMAL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PATTERN_RULEBASED = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PATTERN_SEPARATOR_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PERCENT = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PERCENT_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PERMILL_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PLUS_SIGN_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const POSITIVE_PREFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const POSITIVE_SUFFIX = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const PUBLIC_RULESETS = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUNDING_INCREMENT = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUNDING_MODE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_AWAY_FROM_ZERO = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_CEILING = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_DOWN = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_FLOOR = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_HALFDOWN = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_HALFEVEN = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_HALFODD = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_HALFUP = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_TOWARD_ZERO = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ROUND_UP = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const SCIENTIFIC = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const SECONDARY_GROUPING_SIZE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const SIGNIFICANT_DIGITS_USED = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const SIGNIFICANT_DIGIT_SYMBOL = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const SPELLOUT = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const TYPE_CURRENCY = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const TYPE_DEFAULT = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const TYPE_DOUBLE = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const TYPE_INT32 = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const TYPE_INT64 = _ /* value is not documented */;

	/**
	 * @var int
	 */
	const ZERO_DIGIT_SYMBOL = _ /* value is not documented */;

	#endregion

	#region Functions

	/**
	 * Create a number formatter
	 *
	 * @param string $locale Locale in which the number would be formatted (locale name, e.g. en_CA).
	 * @param int $style Style of the formatting, one of the format style constants. If `NumberFormatter::PATTERN_DECIMAL` or `NumberFormatter::PATTERN_RULEBASED` is passed then the number format is opened using the given pattern, which must conform to the syntax described in » ICU DecimalFormat documentation or » ICU RuleBasedNumberFormat documentation , respectively.
	 * @param string|null $pattern Pattern string if the chosen style requires a pattern.
	 * @return NumberFormatter|null Returns NumberFormatter object or `null` on error.
	 */
	static function create($locale, $style, $pattern = null) { /* function body is hidden */ }

	/**
	 * Format a number
	 * Format a numeric value according to the formatter rules.
	 *
	 * @param float|int $num The value to format. Can be `int` or `float`, other values will be converted to a numeric value.
	 * @param int $type The formatting type to use. Note that `NumberFormatter::TYPE_CURRENCY` is not supported; use NumberFormatter::formatCurrency() instead.
	 * @return bool|string Returns the string containing formatted value, or `false` on error.
	 */
	function format($num, $type = NumberFormatter::TYPE_DEFAULT) { /* function body is hidden */ }

	/**
	 * Format the currency value according to the formatter rules.
	 *
	 * @param float $amount The numeric currency value.
	 * @param string $currency The 3-letter ISO 4217 currency code indicating the currency to use.
	 * @return bool|string String representing the formatted currency value, or `false` on failure.
	 */
	function formatCurrency($amount, $currency) { /* function body is hidden */ }

	/**
	 * Get an attribute
	 * Get a numeric attribute associated with the formatter. An example of a numeric attribute is the number of integer digits the formatter will produce.
	 *
	 * @param int $attribute Attribute specifier - one of the numeric attribute constants.
	 * @return bool|float|int Return attribute value on success, or `false` on error.
	 */
	function getAttribute($attribute) { /* function body is hidden */ }

	/**
	 * Get formatter's last error code
	 * Get error code from the last function performed by the formatter.
	 * @return int Returns error code from last formatter call.
	 */
	function getErrorCode() { /* function body is hidden */ }

	/**
	 * Get formatter's last error message
	 * Get error message from the last function performed by the formatter.
	 * @return string Returns error message from last formatter call.
	 */
	function getErrorMessage() { /* function body is hidden */ }

	/**
	 * Get formatter locale name.
	 *
	 * @param int $type You can choose between valid and actual locale (`Locale::VALID_LOCALE` , `Locale::ACTUAL_LOCALE` , respectively). The default is the actual locale.
	 * @return bool|string The locale name used to create the formatter, or `false` on failure.
	 */
	function getLocale($type = ULOC_ACTUAL_LOCALE) { /* function body is hidden */ }

	/**
	 * Get formatter pattern
	 * Extract pattern used by the formatter.
	 * @return bool|string Pattern `string` that is used by the formatter, or `false` if an error happens.
	 */
	function getPattern() { /* function body is hidden */ }

	/**
	 * Get a symbol value
	 * Get a symbol associated with the formatter. The formatter uses symbols to represent the special locale-dependent characters in a number, for example the percent sign. This API is not supported for rule-based formatters.
	 *
	 * @param int $symbol Symbol specifier, one of the format symbol constants.
	 * @return bool|string The symbol string or `false` on error.
	 */
	function getSymbol($symbol) { /* function body is hidden */ }

	/**
	 * Get a text attribute associated with the formatter. An example of a text attribute is the suffix for positive numbers. If the formatter does not understand the attribute, `U_UNSUPPORTED_ERROR` error is produced. Rule-based formatters only understand `NumberFormatter::DEFAULT_RULESET` and `NumberFormatter::PUBLIC_RULESETS` .
	 *
	 * @param int $attribute Attribute specifier - one of the text attribute constants.
	 * @return bool|string Return attribute value on success, or `false` on error.
	 */
	function getTextAttribute($attribute) { /* function body is hidden */ }

	/**
	 * Parse a number
	 * Parse a string into a number using the current formatter rules.
	 *
	 * @param string $string The string to parse for the number.
	 * @param int $type The formatting type to use. By default, `NumberFormatter::TYPE_DOUBLE` is used. Note that `NumberFormatter::TYPE_CURRENCY` is not supported; use NumberFormatter::parseCurrency() instead.
	 * @param int|null $offset Offset in the string at which to begin parsing. On return, this value will hold the offset at which parsing ended.
	 * @return bool|float|int The value of the parsed number or `false` on error.
	 */
	function parse($string, $type = NumberFormatter::TYPE_DOUBLE, &$offset = null) { /* function body is hidden */ }

	/**
	 * Parse a currency number
	 * Parse a string into a float and a currency using the current formatter.
	 *
	 * @param string $string
	 * @param string $currency Parameter to receive the currency name (3-letter ISO 4217 currency code).
	 * @param int|null $offset Offset in the string at which to begin parsing. On return, this value will hold the offset at which parsing ended.
	 * @return bool|float The parsed numeric value or `false` on error.
	 */
	function parseCurrency($string, &$currency, &$offset = null) { /* function body is hidden */ }

	/**
	 * Set an attribute
	 * Set a numeric attribute associated with the formatter. An example of a numeric attribute is the number of integer digits the formatter will produce.
	 *
	 * @param int $attribute Attribute specifier - one of the numeric attribute constants.
	 * @param float|int $value The attribute value.
	 * @return bool Returns `true` on success or `false` on failure.
	 */
	function setAttribute($attribute, $value) { /* function body is hidden */ }

	/**
	 * Set formatter pattern
	 * Set the pattern used by the formatter. Can not be used on a rule-based formatter.
	 *
	 * @param string $pattern Pattern in syntax described in » ICU DecimalFormat documentation .
	 * @return bool Returns `true` on success or `false` on failure.
	 */
	function setPattern($pattern) { /* function body is hidden */ }

	/**
	 * Set a symbol value
	 * Set a symbol associated with the formatter. The formatter uses symbols to represent the special locale-dependent characters in a number, for example the percent sign. This API is not supported for rule-based formatters.
	 *
	 * @param int $symbol Symbol specifier, one of the format symbol constants.
	 * @param string $value Text for the symbol.
	 * @return bool Returns `true` on success or `false` on failure.
	 */
	function setSymbol($symbol, $value) { /* function body is hidden */ }

	/**
	 * Set a text attribute associated with the formatter. An example of a text attribute is the suffix for positive numbers. If the formatter does not understand the attribute, `U_UNSUPPORTED_ERROR` error is produced. Rule-based formatters only understand `NumberFormatter::DEFAULT_RULESET` and `NumberFormatter::PUBLIC_RULESETS` .
	 *
	 * @param int $attribute Attribute specifier - one of the text attribute constants.
	 * @param string $value Text for the attribute value.
	 * @return bool Returns `true` on success or `false` on failure.
	 */
	function setTextAttribute($attribute, $value) { /* function body is hidden */ }

	/**
	 * Create a number formatter
	 *
	 * @param string $locale Locale in which the number would be formatted (locale name, e.g. en_CA).
	 * @param int $style Style of the formatting, one of the format style constants. If `NumberFormatter::PATTERN_DECIMAL` or `NumberFormatter::PATTERN_RULEBASED` is passed then the number format is opened using the given pattern, which must conform to the syntax described in » ICU DecimalFormat documentation or » ICU RuleBasedNumberFormat documentation , respectively.
	 * @param string|null $pattern Pattern string if the chosen style requires a pattern.
	 * @return mixed Returns NumberFormatter object or `null` on error.
	 */
	function __construct($locale, $style, $pattern = null) { /* function body is hidden */ }

	#endregion
}